/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example.app

import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import static org.mockito.Mockito.*;
import static org.junit.Assert.*;

import org.junit.jupiter.api.Test

import static org.junit.jupiter.api.Assertions.*

public class MessageUtilsTest {

    private MessageUtils messageUtils;
    private def script;

    // @Before public void setUp() {
    //     // Mock the Jenkins pipeline script object
    //     script = Mockito.mock(MessageUtils.class);
    //     messageUtils = new MessageUtils("John", script);
    // }

    @Test public void testHello() {
        // Test simple hello method
        script = Mockito.mock(Object.class);
        messageUtils = new MessageUtils("John", script);
        String result = messageUtils.hello();
        assertEquals("Hello, John!", result);
    }


    @Test
    public void testTryReadYaml() {
        // Mock the Jenkins pipeline script object
        script = new Expando(); // Use Expando for dynamic method mocking
        script.readYaml = { Map args -> [key: 'value'] } // Mock readYaml behavior

        messageUtils = new MessageUtils("John", script);

        // Call the method
        String yamlResult = messageUtils.tryReadYaml();

        // Validate the result
        assertNotNull(yamlResult);
        assertEquals("{key=value}", yamlResult.toString());
    }


    @Test
    public void testTryShCommands() {
        // Mock the Jenkins pipeline script object
        script = new Expando(); // Use Expando for dynamic method mocking

        // Mock the `sh` command
        script.sh = { Map args -> "hello from sh command123" } // Simulate output of the sh command

        messageUtils = new MessageUtils("John", script);

        // Call the method
        String output = messageUtils.tryShCommands();

        // Validate the result
        // assertNotNull(output);
        assertEquals("hello from sh command123", output);
    }


    @Test
    public void testTryReadFile() {
        // Mock the Jenkins pipeline script object
        script = new Expando(); // Use Expando for dynamic method mocking

        // Mock the `readFile` command
        script.readFile = { String fileName -> 
            assertEquals("README.md", fileName) // Ensure correct file is being read
            return "This is the content of README.md"
        }

        messageUtils = new MessageUtils("John", script);

        // Call the method
        String content = messageUtils.tryReadFile();

        // Validate the result
        assertNotNull(content);
        assertEquals("This is the content of README.md", content);
    }

    @Test
    public void testTryClosureWithParams() {
    script = new Expando(); // Expando for dynamic method mocking
    messageUtils = new MessageUtils("John", script);

    // Create a closure with parameters
    Closure mockClosure = { String greeting, String name -> 
        return "${greeting}, ${name}!"
    }

    // Call tryClosure with a closure that has parameters
    String result = messageUtils.tryClosure(mockClosure.curry("Hello", "John"));

    // Validate the result
    assertNotNull(result);
    assertEquals("Hello, John!", result);
    }

    @Test
    public void testTryWithEnv() {
        // Create a single Expando object for script and env
        script = new Expando();
        script.env = new Expando();
        script.env.HELLO = "World"; // Mock the environment variable HELLO

        messageUtils = new MessageUtils("John", script);

        // Call the method
        String result = messageUtils.tryWithEnv();

        // Validate the returned result
        assertEquals("Environment variable: World", result);
    }

    // @Test
    // public void testTryGettingStage() {
    //     // Mock the Jenkins pipeline script object
    //     script = new Expando(); // Use Expando for dynamic method mocking

    //     // Mock the `stage` and `sh` commands
    //     script.stage = { String stageName, Closure body ->
    //         assertEquals("We are testing", stageName) // Ensure the correct stage name is passed
    //         body.call() // Execute the body of the stage
    //     }

    //     script.sh = { Map args -> 
    //         assertEquals('echo "hello from stage"', args.script) // Ensure correct shell script is passed
    //         return "hello from stage"
    //     }

    //     messageUtils = new MessageUtils("John", script);

    //     // Call the method to get the closure
    //     def stageClosure = messageUtils.tryGettingStage();

    //     // Invoke the closure
    //     stageClosure.call();

    //     // Since the method internally prints the result, we don't have an actual return value
    //     // So, we verify the mocked behavior by assertions inside the mocks
    // }

    @Test
    public void testTryGettingStage() {
        // Mock the Jenkins pipeline script object
        script = new Expando(); // Use Expando for dynamic method mocking

        // Mock the `stage` method inside the script context
        script.stage = { String stageName, Closure body ->
            assertEquals("We are testing", stageName) // Ensure the correct stage name is passed
            body.call() // Execute the body of the stage
        }

        // Mock the `sh` command inside the script context
        script.sh = { Map args -> 
            assertEquals('echo "hello from stage"', args.script) // Ensure correct shell script is passed
            return "hello from stage"
        }

        messageUtils = new MessageUtils("John", script);

        // Call the method to get the closure that includes the stage
        def stageClosure = messageUtils.tryGettingStage();

        // Invoke the closure returned by tryGettingStage
        // Notice: The closure must be executed within the context of the script object
        // This ensures that the `stage` and `sh` methods are available within the closure's execution context
        stageClosure.delegate = script
        stageClosure.call();

        // No return value to check, but we've asserted the calls inside the mocks
    }

}